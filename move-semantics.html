<section>
    <h2>Rust Features</h2>
    <ul>
	<li class="fragment highlight-yellow">Move semantics</li>
	<li>Pattern matching</li>
	<li>Guaranteed memory safety</li>
	<li>Type inference</li>
	<li>Trait-based generics</li>
	<li>Zero-cost abstractions</li>
	<li>Threads without data races</li>
	<li>Minimal runtime</li>
	<li>Efficient C bindings</li>
    </ul>
</section>
<section id="move-semantics">
    <h2>Move semantics</h2>
</section>
<section id="move-in-c">
    <h3>Move in C</h3>
    <ul>
	<li class="fragment">
	    In C, a moving is basically just a <code class="hljs-i">memcpy</code> call
	</li>
	<li class="fragment">
	    Program invariants determine if references to the copied-from location are still valid
	</li>
	<li class="fragment">
	    That is, if we intended to move or just copy
	</li>
	<li class="fragment">
	    Hardly any assitance from the compiler regarding to the validity of pointers
	</li>
    </ul>
</section>
<section>
    <h3>Move in C++</h3>
    <ul>
	<li class="fragment">
	    In C++, eventually it was realized that there are too many object constructions, copies, destructions.
	</li>
	<li class="fragment">
	    And they are right, it's bad.
	</li>
	<li class="fragment">
	    By moving the innards of a class to a new memory location, we don't do unnecessary work.
	</li>
	<li class="fragment">
	    So to rectify, there is a special C++ move constructor, since C++11.
	</li>
    </ul>
</section>
<section>
    <h3>Move in C++ (cont')</h3>
    <ul>
	<li class="fragment">
	    Due to backward compatibility, move is not done by default for all values
	</li>
	<li class="fragment">
	    Instead, it is governed by newly introduced 'move reference' (<code class="hljs-i">&&</code>), and <code class="hljs-i">std::move</code>
	</li>
	<li class="fragment">
	    Also, special kind of constructor and assignment operator were added for it
	</li>
	<li class="fragment">
	    Programmers are not sure when to use `std::move` (<a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es56-write-stdmove-only-when-you-need-to-explicitly-move-an-object-to-another-scope">GSL ES.56</a>)
	</li>
    </ul>
</section>
<section>
    <h3>Rust: Move semantics by default</h3>
    <ul>
	<li class="fragment">
	    All types are movable by default.
	</li>
	<li class="fragment">
	    No need to think hard ; This happens everywhere - in assignments, local variable declerations, and parameters passing (examples later on).
	</li>
	<li class="fragment">
	    If a variable is movable, it was guaranteed in compile time that there are no extra references to it during the move in run-time.
	</li>
	<li class="fragment">
	    Moving is <b>safe</b>.
	</li>
    </ul>
</section>
<section>
    <div>In contrast, in C++, beside usage, there are dangers:
	<pre><code class="hljs c++" data-trim contenteditable>
std::vector&lt;int&gt; v = {2, 3, 3};
v = std::move(v); // undefined behavior
    </code></pre></div>
    <ul>
	<li class="fragment">Feels like using 'move' is for the real experts.</li>
	<li class="fragment">Otherwise you risk segfaults.</li>
	<li class="fragment">"Unless otherwise specified, all standard library objects that have been moved from are placed in a valid but unspecified state. That is, only the functions without preconditions, such as the assignment operator, can be safely used on the object after it was moved from"</li>
	<li class="fragment">Behavior depends on the type of object.</li>
    </ul>
</section>
<section>
    <h3>Rust: Move used for construction</h3>
    <ul>
	<li class="fragment">
	    Also, what we usually have as a constructor is just a regular function to wrap native Struct instantiation.
	</li>
	<li class="fragment">
	    Initializing structs and moving them around is what constitutes the C++-equivalent of construction in Rust.
	</li>
	<li class="fragment">
	    In fact, moving is essential to constructors, which are normal 'method-less' function like you'd expect.
	</li>
    </ul>
</section>
<section>
    <h3>Rust: Destruction is simpler</h3>
    <ul>
	<li class="fragment">
	    For destructors of 'moved-from' memory locations, Rust does not rely on optimizations that cancel them out, unlike in C++. They simply don't exist.
	</li>
	<li class="fragment">
	    Instead, we have an optional <code class="hljs-i">Drop</code> code that we can implemented for types
	    when their values go out scope.
	</li>
    </ul>
</section>
<section>
    <div><pre><code class="hljs rust" data-trim contenteditable>
			a = b;
    </code></pre></div>
    <ul>
	<li class="fragment">
	    What does it mean? In either language? In C it is simple.
	</li>
	<li class="fragment">
	    In C++ it means: call a special or implicit copy assignment operator of pre-existing value "a", copying resources from "b". Was "b" modified in this
	    operation? Depending on <i>which</i> copy assigment operator was called.
	</li>
	<li class="fragment">
	    In Rust it means: Drop pre-existing "a" value and then memmove the content of "b" into the place of "a". "b" is no longer accessible afterward - the <b>compiler</b> will give us an error if we try to access it.
	</li>
    </ul>
</section>
<section>
    <div><pre><code class="hljs rust" data-trim contenteditable>
			a = b; // Drop "a" and move "b" into "a"
    </code></pre></div>
    <ul>
	<li>Wait, what? In Rust you... what?</li>
	<li class="fragment">
	    Seems bizzare that we cannot access "b" after this?
	</li>
	<li class="fragment">
	    Makes sense. Think of the case in C where the copied type contains pointers. Now if we do stuff with "a" we need to assure that the pointers in "b" are still valid.
	</li>
	<li class="fragment">
	    There is a very common case in which the type of "a" and "b" is <i>Copyable</i>, such as with type "u32", or types that the developer specifically intends to be that way. In these cases "b" remains accessible and retains a bit-identical copy to "a", just like in 'C'.
	</li>
    </ul>
</section>
<section>
    <ul>
	<li>Anyway, we have very simple rules as to what happens in assignments.</li>
	<li class="fragment">What about parameter passing?</li>
    </ul>
    <div class="fragment"><pre><code style="font-height:50%" class="hljs rust" data-trim contenteditable>
fn func_b(SomeType a) {
println!("{}", a);
}

fn func_a(SomeType a) {
func_b(a)
}

fn example() {
func_a(SomeType::new());
}
	</code></pre></div>
	<ul>
	    <li class="fragment">Only one construction and one drop of SomeType happens here.</li>
	</ul>
</section>
<section>
    <ul>
	<li>But what about stack space in this example? And time it takes to memmove()?</li>
	<li class="fragment">Very good point. Don't panic.</li>
	<li class="fragment">We <i>can</i> pass references instead of moving stuff up and down, in and out of structs.</li>
	<li class="fragment">So, as it turns out, we have pointers to const data and mutable data just like in C/C++.</li>
	<li class="fragment">After wall, Rust is a system programming language.</li>
	<li class="fragment">And here it may get complicated. <span class="fragment">But unlike C++, in a good way!</span></li>
    </ul>
</section>
