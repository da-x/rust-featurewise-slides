<section>
    <h2>Rust Features</h2>
    <ul>
	<li class="fragment highlight-yellow">Move semantics</li>
	<li>Pattern matching</li>
	<li>Guaranteed memory safety</li>
	<li>Type inference</li>
	<li>Trait-based generics</li>
	<li>Zero-cost abstractions</li>
	<li>Threads without data races</li>
	<li>Minimal runtime</li>
	<li>Efficient C bindings</li>
    </ul>
</section>
<section id="move-semantics">
    <h2>Move semantics</h2>
</section>
<section id="move-in-c">
    <h3>Move in C</h3>
    <ul>
	<li class="fragment">
	    In C, a moving is basically just a <code class="hljs-i">memcpy</code> call
	</li>
	<li class="fragment">
	    Program invariants determine if references to the copied-from location are still valid
	</li>
	<li class="fragment">
	    That is, if we intended to move or just copy
	</li>
	<li class="fragment">
	    Hardly any assitance from the compiler regarding to the validity of pointers
	</li>
    </ul>
</section>
<section>
    <h3>Move in C++</h3>
    <ul>
	<li class="fragment">
	    In C++, eventually it was realized that there are too many object constructions, copies, destructions.
	</li>
	<li class="fragment">
	    And they are right, it's bad.
	</li>
	<li class="fragment">
	    By moving the innards of a class to a new memory location, we don't do unnecessary work.
	</li>
	<li class="fragment">
	    So to rectify, there is a special C++ move constructor, since C++11.
	</li>
    </ul>
</section>
<section>
    <h3>Move in C++ (cont')</h3>
    <ul>
	<li class="fragment">
	    Due to backward compatibility, move is not done by default for all values
	</li>
	<li class="fragment">
	    Instead, it is governed by newly introduced 'move reference' (<code class="hljs-i">&&</code>), and <code class="hljs-i">std::move</code>
	</li>
	<li class="fragment">
	    Also, special kind of constructor and assignment operator were added for it
	</li>
	<li class="fragment">
	    Programmers are not sure when to use <code class="hljs-i">std::move</code> (<a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#es56-write-stdmove-only-when-you-need-to-explicitly-move-an-object-to-another-scope">GSL ES.56</a>)
	</li>
    </ul>
</section>
<section>
    <h3>Rust: Move semantics by default</h3>
    <ul>
	<li class="fragment">
	    All types are movable by default, as long as the borrow check determines they are <i>owned</i> in the executing context.
	</li>
	<li class="fragment">
	    No need to think hard ; This happens everywhere - in assignments, local variable declarations,  parameters passing, deconstruction (related the topic of pattern matching), and closure capture.
	</li>
	<li class="fragment">
	    If a variable is movable, it was guaranteed in compile time that there are no extra references to it during the move in run-time.
	</li>
	<li class="fragment">
	    Moving is <b>safe</b>. We cannot use a moved value in its original location.
	</li>
    </ul>
</section>
<section>
    <div>In contrast, in C++, beside usage, there are dangers:
	<pre><code class="hljs c++" data-trim contenteditable>
std::vector&lt;int&gt; v = {2, 3, 3};
v = std::move(v); // undefined behavior
    </code></pre></div>
    <ul>
	<li class="fragment">Feels like using 'move' is for the real experts.</li>
	<li class="fragment">Otherwise you risk segfaults.</li>
	<li class="fragment">"Unless otherwise specified, all standard library objects that have been moved from are placed in a valid but unspecified state. That is, only the functions without preconditions, such as the assignment operator, can be safely used on the object after it was moved from"</li>
	<li class="fragment">Behavior depends on the type of object.</li>
    </ul>
</section>
<section>
    <h3>Rust: Move used for construction</h3>
    <ul>
	<li class="fragment">
	    Also, what we usually have as a constructor is just a regular function to wrap native Struct instantiation.
	</li>
	<li class="fragment">
	    Initializing structs and moving them around is what constitutes the C++-equivalent of construction in Rust.
	</li>
	<li class="fragment">
	    In fact, moving is essential to constructors, which are normal 'method-less' function like you'd expect.
	</li>
    </ul>
</section>
<section>
    Example for move in 'inline construction'
    <div><pre><code style="font-size:100%; line-height: 100%" class="hljs rust" data-trim contenteditable>
struct Point {
    x: u32,
    y: u32,
}

fn main() {
    // The instance of Point below is moved
    // into the function `inner`.
    inner(Point { x: 4, y: 3});
}

fn inner(p: Point)
{
    /* whatever code here */
}
	</code></pre></div>
</section>
<section>
    Example for a "construction" pattern
    <div><pre><code style="font-height:50%" class="hljs rust" data-trim contenteditable>
impl Point {
    fn new(x: u32, y: u32) -> Point {
        // The instance creaet below is moved out
	// to the return value, equivalent to C++ RVO.
        Point { x, y}
    }

    // Another constructor:
    fn with_offset(x: u32, y: u32) -> Point {
        Point { x: x + 1, y: y + 2}
    }
}
	</code></pre></div>
</section>
<section>
    Moving is to function parameters down the stack
    <div><pre><code style="font-size:100%; line-height: 100%" class="hljs rust" data-trim contenteditable>
fn main() {
    inner(Point { x: 4, y: 3});
}

fn inner(Point a) {
    // 'a' is moved from being an incoming parameter
    // of 'inner' to being a parameter of 'receiver'
    receiver(a)
}

fn receiver(Point a) {
    // 'a' is dropped here
}
	</code></pre></div>
</section>
<section>
    <h3>Rust: Destruction is simpler</h3>
    <ul>
	<li class="fragment">
	    For destructors of 'moved-from' memory locations, Rust does not rely on optimizations that cancel them out, unlike in C++. They simply don't exist.
	</li>
	<li class="fragment">
	    Instead, we have an optional <code class="hljs-i">Drop</code> code that we can implemented for types
	    when their values go out scope.
	</li>
    </ul>
</section>
<section>
    <ul>
	<li><code class="hljs-i">Drop</code> by default does nothing, unless it is overriden with <code class="hljs-i">impl</code></li>
	<li>It is called for values that <i>finally</i> went out of scope</li>
    </ul>
    <div><pre><code style="font-size:100%; line-height: 110%" class="hljs rust" data-trim contenteditable>
impl Drop for Point {
    fn drop(&mut self) {
        println!("Point having x={}, y={} dropped",
	          self.x, self.y);
	// If it had resources, we free them here.
    }
}
	</code></pre></div>
</section>
<section>
    <h3>Rust: The 'move from lvalue' treatment</h3>
    <div><pre><code class="hljs rust" data-trim contenteditable>
			a = b;
    </code></pre></div>
    <ul>
	<li class="fragment">
	    What does it mean, depending on the language?
	</li>
	<li class="fragment">
	    In C it is equivalent of <code class="hljs-i">memcpy(&a, &b, sizeof(a))</code>.
	</li>
	<li class="fragment">
	    In C++ it means <i>roughly</i>: call a special or implicit copy or move assignment operator of pre-existing value <code class="hljs-i">a</code>, copying resources from <code class="hljs-i">b</code>. Was <code class="hljs-i">b</code> modified in this operation? Depending on <i>which</i> copy assigment operator was called, depending if <code class="hljs-i">b</code> is a move reference.
	</li>
    </ul>
</section>
<section>
    <div><pre><code class="hljs rust" data-trim contenteditable>
			a = b; // Drop `a` and move `b` into `a`'s address
    </code></pre></div>
    <ul>
	<li class="fragment">
	    Rust will only allow this if both values are owned.
	</li>
	<li class="fragment">
	    It means, call <code class="hljs-i">Drop::drop</code> on pre-existing <code class="hljs-i">a</code> value and then do the equivalent of <code class="hljs-i">memmove</code> of the content of <code class="hljs-i">b</code> into the place of <code class="hljs-i">a</code>. <code class="hljs-i">b</code> is no longer accessible afterward - the <b>compiler</b> will give us an error if we try to access it.
	</li>
	<li class="fragment">
	    <code class="hljs-i">b</code> is inaccessible, unless we the type has <code class="hljs-i">Copy</code> impl, for example:
	</li>
    </ul>
    <div class="fragment"><pre><code style="font-size:99%; line-height: 100%" class="hljs rust" data-trim contenteditable>
#[derive(Copy, Clone)]
struct Point {
    x: u32,
    y: u32,
}
	</code></pre></div>
</section>
<section>
    <h3>Rust: Copy and Clone</h3>
    <ul>
	<li class="fragment">
	    <code class="hljs-i">Copy</code> is an automatic trait for some types, such as borrowed read-only references, or PODs, but can be activated for some user types as well.
	</li>
	<li class="fragment">
	    <code class="hljs-i">Clone</code> is another trait that is equivalent to C++'s <b>copy</b> constructor (<i>hence confusion if you are migrating</i>). In Rust, it's just another optional method (but a trait method).
	</li>
	<li class="fragment">
	    Also, unlike in C++, <code class="hljs-i">.clone()</code> needs to be called explicitly when you want to 'deep copy' a value instead of moving it, which makes the operation clearer than the C++ equivalent.
	</li>
    </ul>
</section>
<section>
    <h3>Rust: Move in deconstruction</h3>
    <div><pre><code style="font-size:100%; line-height: 100%" class="hljs rust" data-trim contenteditable>
fn inner_a(Point a) {
    let Point { x , .. } = a;
    // 'x' is moved out of 'a', 'y' is dropped
    println!("{} x is", x);
}

fn inner_b(Point a) {
    let Point { y: y_another_name , .. } = a;
    // 'y' is moved out of 'a', 'x' is dropped
    println!("{} y is", y_another_name);
}
	</code></pre></div>
</section>
<section>
    <h3>Rust: Method self move</h3>
    <ul>
	<li class="fragment">
	    Unlike in C++, where <code class="hljs-i">this</code> is always a pointer to the current class instance, in Rust it can be the variable itself
	</li>
	<li class="fragment">
	    This means that the method can "consume" the object it is operating on, because it moves itself into being its first parameter.
	</li>
    </ul>
</section>
<section>
    <h3>Rust: Method self move</h3>
    <div><pre><code style="font-size:80%; line-height: 100%" class="hljs rust" data-trim contenteditable>
impl Point {
    fn scale(self, factor: u32) -> Point {
	Point {
	    x: self.x * factor,
	    y: self.y * factor,
	}
    }

    fn mod_x(self, new_x: u32) -> Point {
        // self is moved into here
	Point {
	    x: new_x,
	    y: self.y,
	}
        // self is dropped here
    }
}

fn inner(Point a) {
    let new_a = a.scale(2).mod(1);
    /* 'a' is not accessible here */
}
	</code></pre></div>
</section>
<section>
    <h3>Rust: Move to and from the heap</h3>
    <ul>
	<li class="fragment">
	    The basic <code class="hljs-i">unique_ptr</code> equivalent is named <code class="hljs-i">Box</code>.
	</li>
	<li class="fragment">
	    Values are initialized on the stack moved into it.
	</li>
    </ul>
    <div class="fragment"><pre><code style="font-size:80%; line-height: 100%" class="hljs rust" data-trim contenteditable>
fn simple(p: Point, pbox: Box&lt;Point&gt;) {
    // Move p to the heap
    let p_on_heap = Box::new(p);

    // Move the Point pointed by pbox back to the stack
    let p_on_stack = *pbox;

    /* ... */
}

fn hoopla(mut p: Point, pbox: &mut Box&lt;Point&gt;) {
    // Swap between the points in the Box and on the Stack
    std::mem::swap(&mut p, pbox);

    // The point in pbox was 'reseated' by 'p' and now it is dropped.
}
    </code></pre></div>
    <ul>
	<li class="fragment">
	    There is also a <code class="hljs-i">shared_ptr</code> equivalent named <code class="hljs-i">Rc</code>, which works similarly.
	</li>
    </ul>
</section>
<section>
    <h3>Rust: Move into closures</h3>
    <div class="fragment"><pre><code style="font-size:70%; line-height: 100%" class="hljs rust" data-trim contenteditable>
// Suppose Rect::contains takes Point

fn does_not_build(p: Point, rects: Vec&lt;Rect&gt;) -> Vec&lt;Rect&gt; {
    let vec_without_p =
          rects.into_iter().filter(|rect| !rect.contains(p)).collect();
    let p_try = p;
   /*
    | Compiler error:
    |
    |  let vec_without_p =
    |        rects.into_iter().filter(|rect| !rect.contains(p)).collect();
    |                                 ------ value moved (into closure) here
    |  let p_try = p;
    |      ^ value used here after move
    */
}
    </code></pre></div>
    <div class="fragment"><pre><code style="font-size:70%; line-height: 100%" class="hljs rust" data-trim contenteditable>

// But if it takes &Point, we are good

fn lemme_fix_it(p: Point, rects: Vec&lt;Rect&gt;) -> Vec&lt;Rect&gt; {
    let vec_without_p =
          rects.into_iter().filter(|rect| !rect.contains(&p)).collect();
    let p_try == p;
    /* ... */
}
    </code></pre></div>
</section>
