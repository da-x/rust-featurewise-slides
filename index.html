<!doctype html>
<html>
    <head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
	    var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>
    </head>
    <body>
	<div class="reveal">
	    <div class="slides">
		<section>
		    <span style="font-size:300%">
			<p>Rust</p>
		    </span>
		    <span style="font-size:150%">
			System Programming Language
		    </span>
		</section>
		<section>
		    <h2>System Programming</h2>
		    <ul>
			<li class="fragment">Fine control over:</li>
			<ul>
			    <li class="fragment">Memory allocations and layout: means no forced garbage collector and object management</li>
			    <li class="fragment">Hardware access: threading and execution</li>
			</ul>
			<li class="fragment">Allow to control performance at any level</li>
			<li class="fragment">Allow the programmer control over generated machine code and flow</li>
			<li class="fragment">Let's program everything in assembly!</li>
			<li class="fragment"><span style="color:red">NOT...</span></li>
		    </ul>
		</section>
		<section>
		    <h2>System Programming: Challenges</h2>
		    <ul>
			<li class="fragment">Because we want 'everything' - </li>
			<li class="fragment">How to prevent programming mistakes with all this fine control?</li>
			<li class="fragment">How to maintain correctness while achieving performance?</li>
			<li class="fragment">Is there a holy grail of max correctness and max control?</li>
		    </ul>
		</section>
		<section>
		    <h2>Languages</h2>
		    <ul>
			<li class="fragment">We need a staticly typed, compiled language</li>
			<li class="fragment">C: Has basic types, simple standard, hardly any correctness guarantees</li>
			<li class="fragment">C++: Has generic types, very complex and problematic (next slides)</li>
			<li class="fragment">Go: Has basic types and very simple generic types</li>
			<li class="fragment">Java: Has memory management, GC, and generic types</li>
			<li class="fragment">We want something better, best of all worlds</li>
		    </ul>
		</section>
		<section>
		    <h2>Rust Features</h2>
		    <ul>
			<li class="fragment highlight-yellow">Pattern matching</li>
			<li>Guaranteed memory safety</li>
			<li>Move semantics</li>
			<li>Type inference</li>
			<li>Trait-based generics</li>
			<li>Zero-cost abstractions</li>
			<li>Threads without data races</li>
			<li>Minimal runtime</li>
			<li>Efficient C bindings</li>
		    </ul>
		</section>
		<section>
		    <section>
			<h2>Struct Deconstruction</h2>
			<p class="fragment">First, let's look at Struct Deconstruction</p>
			<div class="fragment">If a function returns a tuple, Python lets you do:
			    <pre><code class="hljs python" data-trim contenteditable>
(a, b) = func()
			    </code></pre>
			</div>
			<div class="fragment">Instead of:
			    <pre><code class="hljs python" data-trim contenteditable>
value = func()
a = value[0]
b = value[1]

			    </code></pre>
			</div>
		    </section>
		    <section>
			<h2>Struct Deconstruction</h2>
			<p class="fragment">Imagine the same thing with C.</p>
			<div class="fragment">Now in Rust, suppose we have this struct:
			    <pre class="fragment"><code class="hljs rust" data-trim contenteditable>
struct Example {
    some_int: u32,
    some_string: String,
}
			</code></pre></div>
			<div class="fragment">We can deconstruct it, assigning the names locally
			    <pre class="fragment"><code class="hljs rust" data-trim contenteditable>
let Example { some_int, some_string } = func()
println!("{}", some_int);
			</code></pre></div>
		    </section>
		    <section>
			<h2>Struct Deconstruction</h2>
			<div class="fragment">We don't have to use the same names
			    <pre class="fragment"><code class="hljs rust" data-trim contenteditable>
let Example { some_int: bla, some_string } = func()
println!("{}", bla);
			</code></pre></div>
			<div class="fragment">Or get them all
			    <pre class="fragment"><code class="hljs rust" data-trim contenteditable>
let Example { .., some_string } = func()
println!("{}", some_string);
			</code></pre></div>
		    </section>
		    <section>
			<h2>Pattern Matching</h2>
			<ul>
			    <li class="fragment">Used with struct deconstruction, like in Python</li>
			    <li class="fragment">Accessing fields of structs without repetitively naming them</li>
			    <li class="fragment">And for accessing tagged unions <b>safely</b></li>
			    <li class="fragment">Tagged unions == variant types == sum types</li>
			</ul>
		    </section>
		    <section>
			C: Tagged union definition
			<pre><code class="hljs c" data-trim contenteditable>
enum code {
    CODE__OK,
    CODE__ERR_WITH_VAL,
    CODE__ERR_WITH_STR,
};

struct code_struct {
    enum code tag;
    union {
	int val;
	const char *str;
    } u;
};
			</code></pre>
		    </section>
		    <section>
			C: Tagged union access
			<pre><code class="hljs c" data-trim contenteditable>
void example(struct code_struct cs) {
    switch (cs.tag) {
    case CODE__OK:
	printf("OK\n");
	break;
    case CODE__ERR_WITH_VAL:
	printf("%d\n", cs.u.val);
	break;
    case CODE__ERR_WITH_STR:
	printf("%s\n", cs.u.str);
	break;
    }
}
			</code></pre>
		    </section>
		    <section>
			Rust: Same tagged union
			<pre><code class="hljs rust" data-trim contenteditable>
enum Code {
    Ok,
    ErrVal(u32),
    ErrStr(String),
}

fn example(Code cs) {
    match cs {
	Code::Ok => println!("OK"),
	Code::ErrVal(val) => println!("{}", val),
	Code::ErrStr(val) => println!("{}", val),
    }
}
			</code></pre>
		    </section>
		    <section>
			Rust: Construction is also easier
			<pre><code class="hljs rust" data-trim contenteditable>
			Code::Ok
			</code></pre>

			<pre><code class="hljs rust" data-trim contenteditable>
			Code::ErrVal(3)
			</code></pre>

			<pre><code class="hljs rust" data-trim contenteditable>
			Code::ErrString(String::new("A"))
			</code></pre>

			NOTE: This `String` type is heap-allocated for simplicity of the example,
			but we could have used a reference string type with usage-dependent
			memory location.
		    </section>
		    <section>
			Rust: Deconstruction can be more elaborate
			<pre><code style="font-height:50%" class="hljs rust" data-trim contenteditable>
enum Shape {
    Rect(u32, u32),
    Cube(u32, u32, u32),
}

fn example(Shape cs) {
    match cs {
	Code::Rect(1, _) =>
  	   println!("Rect with 1 as first dimension"),
	Code::Rect(_, 1) =>
	   println!("Rect with 1 as second dimension"),
	Code::Rect(_, _) =>
	   println!("All other boxes"),
	Code::Cube(_, width, ) =>
	   println!("I only care about Cube width", width),
	_ => println!("all other possibilities"),
    }
}
			</code></pre>
		    </section>
		    <section>
			Rust: Option - A very useful type
			<pre><code style="font-height:50%" class="hljs rust" data-trim contenteditable>
enum Option&lt;T&gt; {
    None,
    Some(T),
}
			</code></pre>
		    </section>
		</section>
	    </div>
	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>

	<script>
	    // More info about config & dependencies:
	    // - https://github.com/hakimel/reveal.js#configuration
	    // - https://github.com/hakimel/reveal.js#dependencies
	    Reveal.initialize({
			      dependencies: [
				  { src: 'plugin/markdown/marked.js' },
				  { src: 'plugin/markdown/markdown.js' },
				  { src: 'plugin/notes/notes.js', async: true },
				  { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
			      ]
	    });
	</script>
    </body>
</html>
