
<!doctype html>
<html>
    <head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/black.css">

	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
	    var link = document.createElement( 'link' );
link.rel = 'stylesheet';
link.type = 'text/css';
link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
document.getElementsByTagName( 'head' )[0].appendChild( link );
	</script>
    </head>
    <body>
	<div class="reveal">
	    <div class="slides">
<section>
    <span style="font-size:250%">
	<p>Rust</p>
    </span>
    <span style="font-size:130%">
	<p>System Programming Language</p>
    </span>
    <div style="font-size:80%">
	<p><i>An introduction for C/C++ programmers</i></p>
    </div>
</section>
<section>
    <h2>System Programming</h2>
    <ul>
	<li class="fragment">Fine control over:</li>
	<ul>
	    <li class="fragment">Memory allocations and layout: means no forced garbage collector and object management</li>
	    <li class="fragment">Hardware access: threading and execution</li>
	</ul>
	<li class="fragment">Allow to control performance at any level</li>
	<li class="fragment">Allow the programmer control over generated machine code and flow</li>
	<li class="fragment">Let's program everything in assembly!</li>
	<li class="fragment"><span style="color:red">NOT...</span></li>
    </ul>
</section>
<section>
    <h2>Languages</h2>
    <ul>
	<li class="fragment">We need a staticly typed, compiled language</li>
	<li class="fragment">Go: Has basic types, very limited generics, and GC</li>
	<li class="fragment">Java: Has memory management, generics, and GC</li>
	<li class="fragment">C: Too basic for our needs</li>
	<li class="fragment">C++: It is well established, has many advantages, but carries a lot of design baggage</li>
    </ul>
    C++ is as a serious contender, let's compare it with Rust -
</section>
<section data-external="challenges.html"></section>
<section>
    <section>
	<h2>Rust Features</h2>
	<ul>
	    <li class="fragment highlight-yellow">Move semantics</li>
	    <li>Pattern matching</li>
	    <li>Guaranteed memory safety</li>
	    <li>Type inference</li>
	    <li>Trait-based generics</li>
	    <li>Zero-cost abstractions</li>
	    <li>Threads without data races</li>
	    <li>Minimal runtime</li>
	    <li>Efficient C bindings</li>
	</ul>
    </section>
    <section>
	<h2>Move semantics</h2>
    </section>
    <section>
	<h3>Move in C++</h3>
	<ul>
	    <li class="fragment">
		Remember 'Constructors' and 'Destructors' in C++?
	    </li>
	    <li class="fragment">
		Yikes...
	    </li>
	    <li class="fragment">
		In C++, eventually it was realized that there are too many object constructions, copies, destructions.
	    </li>
	    <li class="fragment">
		And they are right, it's bad.
	    </li>
	    <li class="fragment">
		By moving the innards of a class to a new memory location, we don't do unnecessary work.
	    </li>
	    <li class="fragment">
		So to rectify, there is a special C++ move constructor, since C++11.
	    </li>
	</ul>
    </section>
    <section>
	<div>In C++, 'move constructor' and 'move assigment' look like this:
	    <pre class="fragment"><code class="hljs c++" data-trim contenteditable>
// Simple move constructor
A(A&& arg) : member(std::move(arg.member))
{}

// Simple move assignment operator
A& operator=(A&& other) {
     member = std::move(other.member);
     return *this;
}
	</code></pre></div>
    </section>
    <section>
	<div>Example program
	    <pre class="fragment"><code class="hljs c++" data-trim contenteditable>
int main()
{
    std::string str = "Hello";
    std::vector&lt;std::string&gt; v;

    v.push_back(str);
    std::cout << "After copy, str is \"" << str << "\"\n";

    v.push_back(std::move(str));
    std::cout << "After move, str is \"" << str << "\"\n";

    std::cout << "The contents of the vector are \"" << v[0]
        << "\", \"" << v[1] << "\"\n";
}
	</code></pre></div>
	<div class="fragment">'Moved from' location should remain valid
	    after move because it is deconstructed later.</div>
    </section>
    <section>
	<div>Output
	    <pre><code class="hljs c++" data-trim contenteditable>
After copy, str is "Hello"
After move, str is ""
The contents of the vector are "Hello", "Hello"
	</code></pre></div>
    </section>
    <section>
	<div>BTW, you should be careful with move, because:
	    <pre><code class="hljs c++" data-trim contenteditable>
std::vector&lt;int&gt; v = {2, 3, 3};
v = std::move(v); // undefined behavior
	</code></pre></div>
	<ul>
	    <li class="fragment">Feels like using 'move' is for the real experts.</li>
	    <li class="fragment">Otherwise you risk segfaults.</li>
	    <li class="fragment">"Unless otherwise specified, all standard library objects that have been moved from are placed in a valid but unspecified state. That is, only the functions without preconditions, such as the assignment operator, can be safely used on the object after it was moved from"</li>
	</ul>
    </section>
    <section>
	<ul>
	    <li>
		C++: We haven't even mentioned: error handling in constructors, exceptions from virtual destructors.
	    </li>
	    <li class="fragment">
		Perhaps 'default/copy/move constructors' and 'assignment constructors' were wrong to being with.
	    </li>
	    <li class="fragment">
		Coupling allocation (stack or heap) with initialization and construction was clearly a poor design choice.
	    </li>
	    <li class="fragment">
		Same with coupling de-allocation with de-initialization and destruction.
	    </li>
	    <li class="fragment">
		And 'move', why it should it even allow a special implementation?
	    </li>
	    <li class="fragment">
		Why not just C's 'memmove()'?
	    </li>
	</ul>
    </section>
    <section>
	<h3>Rust: Move semantics by default</h3>
	<ul>
	    <li class="fragment">
		All types are movable by default (under compiler-verified memory safety).
	    </li>
	    <li class="fragment">
		Yes, it's 'memmove()'-like behind the scenes.
	    </li>
	    <li class="fragment">
		No need to think hard ; This happens everywhere - in assignments, local variable declerations, and parameters passing.
	    </li>
	    <li class="fragment">
		Also, what we usually have as a constructor is just a regular function to wrap native Struct instantiation.
	    </li>
	    <li class="fragment">
		Recall the Factory pattern the C++ experts advocate.
	    </li>
	</ul>
    </section>
    <section>
	<h3>Rust: Move semantics by default</h3>
	<ul>
	    <li class="fragment">
		These are even more efficient than C++'s 'move', because when a 'moved from'
		location goes out of scope, so we don't need a destructor call there.
	    </li>
	    <li class="fragment">
		Instead, we have an optional `Drop` code that we can implemented for types
		when their values go out scope.
	    </li>
	</ul>
    </section>
    <section>
	<div><pre><code class="hljs rust" data-trim contenteditable>
			    a = b;
	</code></pre></div>
	<ul>
	    <li class="fragment">
		What does it mean? In either language? In C it is simple.
	    </li>
	    <li class="fragment">
		In C++ it means: call a special or implicit copy assignment operator of pre-existing value "a", copying resources from "b". Was "b" modified in this
		operation? Depending on <i>which</i> copy assigment operator was called.
	    </li>
	    <li class="fragment">
		In Rust it means: Drop pre-existing "a" value and then memmove the content of "b" into the place of "a". "b" is no longer accessible afterward - the <b>compiler</b> will give us an error if we try to access it.
	    </li>
	</ul>
    </section>
    <section>
	<div><pre><code class="hljs rust" data-trim contenteditable>
			    a = b; // Drop "a" and move "b" into "a"
	</code></pre></div>
	<ul>
	    <li>Wait, what? In Rust you... what?</li>
	    <li class="fragment">
		Seems bizzare that we cannot access "b" after this?
	    </li>
	    <li class="fragment">
		Makes sense. Think of the case in C where the copied type contains pointers. Now if we do stuff with "a" we need to assure that the pointers in "b" are still valid.
	    </li>
	    <li class="fragment">
		There is a very common case in which the type of "a" and "b" is <i>Copyable</i>, such as with type "u32", or types that the developer specifically intends to be that way. In these cases "b" remains accessible and retains a bit-identical copy to "a", just like in 'C'.
	    </li>
	</ul>
    </section>
    <section>
	<ul>
	    <li>Anyway, we have very simple rules as to what happens in assignments.</li>
	    <li class="fragment">What about parameter passing?</li>
	</ul>
	<div class="fragment"><pre><code style="font-height:50%" class="hljs rust" data-trim contenteditable>
fn func_b(SomeType a) {
    println!("{}", a);
}

fn func_a(SomeType a) {
    func_b(a)
}

fn example() {
    func_a(SomeType::new());
}
	    </code></pre></div>
	    <ul>
		<li class="fragment">Only one construction and one drop of SomeType happens here.</li>
	    </ul>
    </section>
    <section>
	<ul>
	    <li>But what about stack space in this example? And time it takes to memmove()?</li>
	    <li class="fragment">Very good point. Don't panic.</li>
	    <li class="fragment">We <i>can</i> pass references instead of moving stuff up and down, in and out of structs.</li>
	    <li class="fragment">So, as it turns out, we have pointers to const data and mutable data just like in C/C++.</li>
	    <li class="fragment">After wall, Rust is a system programming language.</li>
	    <li class="fragment">And here it may get complicated. <span class="fragment">But unlike C++, in a good way!</span></li>
	</ul>
    </section>
</section>
<section>
    <section>
	<h2>Rust Features</h2>
	<ul>
	    <li>Move semantics</li>
	    <li class="fragment highlight-yellow">Pattern matching</li>
	    <li>Guaranteed memory safety</li>
	    <li>Type inference</li>
	    <li>Trait-based generics</li>
	    <li>Zero-cost abstractions</li>
	    <li>Threads without data races</li>
	    <li>Minimal runtime</li>
	    <li>Efficient C bindings</li>
	</ul>
    </section>
    <section>
	<h2>Pattern Matching</h2>
    </section>
    <section>
	<h3>Struct Deconstruction</h3>
	<p class="fragment">First, let's look at Struct Deconstruction</p>
	<div class="fragment">If a function returns a tuple, Python lets you do:
	    <pre><code class="hljs python" data-trim contenteditable>
(a, b) = func()
	    </code></pre>
	</div>
	<div class="fragment">Instead of:
	    <pre><code class="hljs python" data-trim contenteditable>
value = func()
a = value[0]
b = value[1]

	    </code></pre>
	</div>
    </section>
    <section>
	Imagine the same thing with C.
	<div class="fragment">Now in Rust, suppose we have this struct:
	    <pre class="fragment"><code class="hljs rust" data-trim contenteditable>
struct Example {
    some_int: u32,
    some_string: String,
}
	</code></pre></div>
	<div class="fragment">We can deconstruct it, assigning the names locally
	    <pre class="fragment"><code class="hljs rust" data-trim contenteditable>
let Example { some_int, some_string } = func();
println!("{}", some_int);
	</code></pre></div>
    </section>
    <section>
	<div>We don't have to use the same names
	    <pre class="fragment"><code class="hljs rust" data-trim contenteditable>
let Example { some_int: bla, some_string } = func();
println!("{}", bla);
	</code></pre></div>
	<div class="fragment">Or get them all
	    <pre class="fragment"><code class="hljs rust" data-trim contenteditable>
let Example { .., some_string } = func();
println!("{}", some_string);
	</code></pre></div>
    </section>
    <section>
	Combine deconstruction with equality to literals:
	<pre><code class="hljs rust" data-trim contenteditable>
match test() {
    Example { some_int: 3, some_string } =>
	println!("Int was three, string was {}",
		 some_string),
    Example { .., some_string } =>
	println!("Int was anything else, string was {}",
		 some_string),
}
	</code></pre>
	<span class="fragment">Like an advanced form of C's 'switch', right?</span>
    </section>
    <section>
	<h2>Pattern Matching</h2>
	<ul>
	    <li class="fragment">Especially useful for accessing tagged unions <b>safely</b></li>
	    <li class="fragment">Tagged unions == variant types == sum types</li>
	</ul>
    </section>
    <section>
	C: Tagged union definition
	<pre><code class="hljs c" data-trim contenteditable>
enum code {
    CODE__OK,
    CODE__ERR_WITH_VAL,
    CODE__ERR_WITH_STR,
};

struct code_struct {
    enum code tag;
    union {
	int val;
	const char *str;
    } u;
};
	</code></pre>
    </section>
    <section>
	C: Tagged union access
	<pre><code class="hljs c" data-trim contenteditable>
void example(struct code_struct cs) {
    switch (cs.tag) {
    case CODE__OK:
	printf("OK\n");
	break;
    case CODE__ERR_WITH_VAL:
	printf("%d\n", cs.u.val);
	break;
    case CODE__ERR_WITH_STR:
	printf("%s\n", cs.u.str);
	break;
    }
}
	</code></pre>
    </section>
    <section>
	Rust: Same tagged union
	<pre><code class="hljs rust" data-trim contenteditable>
enum Code {
    Ok,
    ErrVal(u32),
    ErrStr(String),
}

fn example(Code cs) {
    match cs {
	Code::Ok => println!("OK"),
	Code::ErrVal(val) => println!("{}", val),
	Code::ErrStr(val) => println!("{}", val),
    }
}
	</code></pre>
    </section>
    <section>
	If 'match' not exhausive we get a compilation error.
    </section>
    <section>
	In Rust, construction is also easier
	<pre><code class="hljs rust" data-trim contenteditable>
			Code::Ok
	</code></pre>

	<pre><code class="hljs rust" data-trim contenteditable>
			Code::ErrVal(3)
	</code></pre>

	<pre><code class="hljs rust" data-trim contenteditable>
			Code::ErrString(String::new("A"))
	</code></pre>

	<div class="fragment">NOTE: The content of this `String` type is heap-allocated
	    for simplicity of the example, but we could have used a reference string
	    type with usage-dependent memory location.</div>
    </section>
    <section>
	Rust: Deconstruction can be more elaborate
	<pre><code style="font-height:50%" class="hljs rust" data-trim contenteditable>
enum Shape {
    Rect(u32, u32),
    Cube(u32, u32, u32),
}

fn example(Shape cs) {
    match cs {
	Shape::Rect(1, _) =>
	   println!("Rect with 1 as first dimension"),
	Shape::Rect(_, 1) =>
	   println!("Rect with 1 as second dimension"),
	Shape::Rect(_, _) =>
	   println!("All other boxes"),
	Shape::Cube(width, _, 10) =>
	   println!("Only certain Cube's width {}", width),
	_ => println!("all other possibilities"),
    }
}
	</code></pre>
    </section>
    <section>
	Rust: Option - A very useful type
	<pre><code style="font-height:50%" class="hljs rust" data-trim contenteditable>
enum Option&lt;T&gt; {
    None,
    Some(T),
}
	</code></pre>
    </section>
</section>
<section>
    <section>
	<h2>Rust Features</h2>
	<ul>
	    <li>Move semantics</li>
	    <li>Pattern matching</li>
	    <li class="fragment highlight-yellow">Guaranteed memory safety</li>
	    <li>Type inference</li>
	    <li>Trait-based generics</li>
	    <li>Zero-cost abstractions</li>
	    <li>Threads without data races</li>
	    <li>Minimal runtime</li>
	    <li>Efficient C bindings</li>
	</ul>
    </section>
    <section>
	<h3>Pointer safety</h3>
	<ul>
	    <li>Pointers are essential part of system programming.</li>
	    <li class="fragment">In C, the most trivial example is passing a pointer.</li>
	</ul>
	<div><pre class="fragment"><code class="hljs c" data-trim contenteditable>
void func(struct item *ptr) {
    /* ... */
}</code></pre></div>
	<ul>
	    <li class="fragment">By convention some have NULL value, and others valid addresses.</li>
	</ul>
	<div><pre class="fragment"><code class="hljs c" data-trim contenteditable>
	   func(NULL);
	</code></pre></div>
	<div><pre class="fragment"><code class="hljs c" data-trim contenteditable>
	   /* Given an 'struct item bar' in scope */
	   func(&bar);
	</code></pre></div>
    </section>
    <section>
	<ul>
	    <li>However only by API we are told what is done with the pointer.</li>
	    <li class="fragment">Does the function performs a NULL check?</li>
	    <li class="fragment">Can it be NULL at all?</li>
	    <li class="fragment">Does the function save the pointer?</li>
	    <li class="fragment">If so, until when it is expected to be remained valid by the API?</li>
	    <li class="fragment">Is it accssed from another thread? Do I need to apply locks?</li>
	</ul>
    </section>
    <section>
	<ul>
	    <li>C++ has some "improvements" over this, using references.
		<div><pre class="fragment"><code class="hljs c" data-trim contenteditable>
void func(Item &ref) {
    /* ... */
}</code></pre></div>
	    </li>
	    <li class="fragment">Alright, now we <b>cannot</b> pass NULL.
		<div><pre class="fragment"><code class="hljs c" data-trim contenteditable>
	   // Given an 'struct item bar' in scope, pass a reference
	   func(bar);
	    </code></pre></div></li>
	    <li class="fragment">
		We have not passed "bar", but a reference to "bar".
	    </li>
	    <li class="fragment">
		It <b>does not</b> look from the function call that 'func' can modify 'bar', but it
		can. WTF?
	    </li>
	</ul>
    </section>
    <section>
	<ul>
	    <li>Unrelated to safety, my gripe with C++ is that the same function could have been defined as such:
	<div><pre class="fragment"><code class="hljs c" data-trim contenteditable>
void func(Item item) {
    /* ... */
}</code></pre></div>
	    </li>
	    <li class="fragment">And the call will remain the same:
		<div><pre class="fragment"><code class="hljs c" data-trim contenteditable>
func(bar);
		</code></pre></div>
	    </li>
	    <li class="fragment">Does not say anything on whether we are temporarily creating a copy of an Item or passing a mutable reference to an existing one.</li>
	</ul>
    </section>
    <section>
	<ul>
	    <li>At least to fix against mutability of the item, we can add 'const':
		<div><pre class="fragment"><code class="hljs c" data-trim contenteditable>
void func(const Item &ref) {
    /* ... */
}</code></pre></div>
	    </li>
	    <li class="fragment">
		Still, func() can save a pointer to the Item, so we still have the lifetime issue, loosely defined in APIs.
	    </li>
	</ul>
    </section>
    <section>
	<ul>
	    <li>In C++, there are smart pointers such as "std::unique_ptr":
		<div><pre class="fragment"><code class="hljs c" data-trim contenteditable>
void func(std::unique_ptr&lt;Item&gt; item) {
    /* ... */
}</code></pre></div>
	    </li>
	    <li class="fragment">
		<b>Disadvantage</b>: Now it has to be on the heap, unless we laborously use a more extended type which gets a deleter function as a parameter.
	    </li>
	</ul>
    </section>
    <section>
		<div><pre><code class="hljs c" data-trim contenteditable>
struct Item {
    int mul;
    Item(int x, int y) : mul (x * y) { }
};

void func(std::unique_ptr&lt;Item&gt; item) {}

int main()
{
    std::unique_ptr&lt;Item&gt; bla(new Item(1, 3));
    func(std::move(bla));
}
</code></pre></div>
    </section>
    <section>
	And with `const`:
		<div><pre><code class="hljs c" data-trim contenteditable>
struct Item {
    int mul;
    Item(int x, int y) : mul (x * y) { }
};

void func_const(std::unique_ptr&lt;const Item&gt; item) {}

int main()
{
    std::unique_ptr&lt;Item&gt; bla(new Item(1, 3));
    func_const(std::move(bla));
}
</code></pre></div>
    </section>
    <section>
	<ul>
	    <li>
		What other tools do we have to deal with pointer validity?
	    </li>
	    <li class="fragment">
		In C++, std::shared_ptr&lt;T&gt;
	    </li>
	    <li class="fragment">
		But use Boost's intrusive reference count, because it sits <b>with</b> the object in memory, and does not add pointer indirection.
	    </li>
	    <li class="fragment">
		Maintaining a dynamic reference count has a performance penality, and we would have to use the dreaded std::move everywhere to avoid incref/decref to some extent.
	    </li>
	    <li class="fragment">
		What we really want is to pass around references without fear.
	    </li>
	</ul>
    </section>
    <section>
	<h3>Rust: Safe references</h3>
	<ul>
	    <li class="fragment">
		By 'safe', means that programming error cannot cause invalid references in run-time.
	    </li>
	    <li class="fragment">
		Instead, mishandling references is caught in compile-time.
	    </li>
	    <li class="fragment">
		No run-time overhead, in contrast to reference-count based references.
	    </li>
	    <li class="fragment">
		No data races: Multiple const references are allowed to the same data, only one mutable reference is allowed with no concurrent const references.
	    </li>
	    <li class="fragment">
		Pointed data will not move or be dropped for the lifetime of the reference.
	    </li>
	</ul>
    </section>
    <section>
	<ul>
	    <li>
		Use '&' to create a const reference:
	    </li>
	</ul>
	<div><pre><code class="hljs rust" data-trim contenteditable>
struct Item {
    val: u32,
}

fn simple(item: &Item) {
    // Can only read stuff from 'item'
}

fn main()
{
    let item = Item { val : 2 };
    simple(&item);
}
	</code></pre></div>
    </section>
    <section>
	Use '&mut ' to create a reference that allow mutation:
	<div><pre><code class="hljs rust" data-trim contenteditable>
struct Item {
    val: u32,
}

fn simple_mut(item: &mut Item)
{
    item.val += 1;
}

fn main()
{
    let mut item = Item { val : 2 };
    simple_mut(&mut item);
    simple(&item);
}
	</code></pre></div>
	<div class="fragment">
	    The syntax for creating a reference matches the syntax of declaring its usage. Nice!
	</div>
    </section>
    <section>
	<ul>
	    <li>
		C-like pointers `*mut` and `*const` exist, called "unsafe references" in rust.
	    </li>
	    <li class="fragment">
		To dereference them, or cast them to '&mut' and '&', you wrap the code with 'unsafe {}', to turn off the Rust 'safety protocols'.
	    </li>
	</ul>
    </section>
    <section>
	<h3>Lifetimes</h3>
	<ul>
	    <li>Lifetimes a inherent part of the Rust's type system</li>
	    <li class="fragment">
		Every stack variable, parameter, or reference has a lifetime.
	    </li>
	    <li class="fragment">
		Lifetimes are used for validating references in compile-time.
	    </li>
	    <li class="fragment">
		On most cases lifetimes are infered.
	    </li>
	    <li class="fragment">
		On others they can be specified.
	    </li>
	</ul>
    </section>
    <section>
	Structs can have fields that are safe references:
	<div><pre><code class="hljs rust" data-trim contenteditable>
struct Item&lt;'a&gt; {
    val: u32,
    other: &'a Other,
}
	</code></pre></div>
	<ul>
	    <li class="fragment">
		The `'&lt;name&gt;` thing is a life-time specifier, here it is a parameter of the type.
	    </li>
	    <li class="fragment">
		Here, an instance of Item must be constructed with a givn reference to an 'Other'.
	    </li>
	    <li class="fragment">
		It is guranteed in compile time that the reference to the 'Other' instance will be
		valid while the instance of 'Item' is in scope.
	    </li>
	</ul>
    </section>
    <section>
	Remember this?
	<pre><code style="font-height:50%" class="hljs rust" data-trim contenteditable>
enum Option&lt;T&gt; {
    None,
    Some(T),
}
	</code></pre>
	<div class="fragment">
	Let's have:
	<pre><code style="font-height:50%" class="hljs rust" data-trim contenteditable>
fn func(item: Some<&Item>) {
    match item {
	None => println!("No pointer"),
	Some(item) =>
	    println!("Always valid item: {}", item),
    }
}
	</code></pre>
	</div>
	<div class="fragment">
	    We won!
	</div>
    </section>
    <section>
	<ul>
	    <li>
		There is a special lifetime 'static', which marks references to a static read-only value, and is valid for the whole execution of the program.
	    </li>
	</ul>
	<div><pre><code class="hljs rust" data-trim contenteditable>
enum Other { SomeVal }

struct Item {
    val: u32,
    other: &'static Other,
}

static OTHER : Other = Other::SomeVal;

fn main() {
    let item = Item { val: 3, other: &OTHER };
}
	</code></pre></div>
    </section>
</section>

	    </div>
	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>

	<script>
	    // More info about config & dependencies:
	    // - https://github.com/hakimel/reveal.js#configuration
	    // - https://github.com/hakimel/reveal.js#dependencies
	    Reveal.initialize({
			      dependencies: [
				  { src: 'plugin/markdown/marked.js' },
				  { src: 'plugin/markdown/markdown.js' },
                                  { src: 'plugin/external/external.js', condition: function() { return !!document.querySelector( '[data-external]' ); } },
				  { src: 'plugin/notes/notes.js', async: true },
				  { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
			      ]
	    });
	</script>
    </body>
</html>
