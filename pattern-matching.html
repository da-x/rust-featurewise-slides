<section>
    <h2>Rust Features</h2>
    <ul>
	<li>Move semantics</li>
	<li style="color: #ffff00">Pattern matching</li>
	<li>Guaranteed memory safety</li>
	<li>Trait-based generics</li>
	<li>Type inference</li>
	<li>Zero-cost abstractions</li>
	<li>Threads without data races</li>
	<li>Minimal runtime</li>
	<li>Efficient C bindings</li>
    </ul>
</section>
<section>
    <h2>Pattern Matching</h2>
</section>
<section>
    <h3>Struct Deconstruction</h3>
    <ul>
	<li class="fragment">
	    First, let's look at Struct Deconstruction
	</li>
	<li class="fragment">If a function returns a tuple, Python lets you do:
	    <pre><code class="hljs python" data-trim contenteditable>
(a, b) = func()
	    </code></pre>
	</li>
	<li class="fragment">Instead of:
	    <pre><code class="hljs python" data-trim contenteditable>
value = func()
a = value[0]
b = value[1]

	    </code></pre>
	</li>
    </ul>
</section>
<section>
    <ul>
	<li class="fragment">Now in Rust, suppose we have this struct:
	    <pre><code class="hljs rust" data-trim contenteditable>
struct Example {
    age: u32,
    name: String,
}
	</code></pre></li>
	<li class="fragment">We can deconstruct it, assigning the names locally:
	    <pre><code class="hljs rust" data-trim contenteditable>
let Example { age, name } = func();
println!("{}", age);
	</code></pre></li>
    </ul>
</section>
<section>
    <ul>
	<li>We don't have to use the same names:
	    <pre><code class="hljs rust" data-trim contenteditable>
let Example { age: boo, name } = func();
println!("{}", boo);
	</code></pre></li>
	<li class="fragment">Or get all of them:
	    <pre><code class="hljs rust" data-trim contenteditable>
let Example { .., name } = func();
println!("{}", name);
	</code></pre></li>
    </ul>
</section>
<section>
    <ul>
        <li>Combine deconstruction with equality to literals:</li>
    </ul>
    <pre><code class="hljs rust" data-trim contenteditable>
match test() {
    Example { age: 3, name } =>
	println!("Int was three, string was {}",
		 name),
    Example { .., name } =>
	println!("Int was anything else, string was {}",
		 name),
}
    </code></pre>
    <span class="fragment">Like an advanced form of C's 'switch', right?</span>
</section>
<section>
    <h2>Pattern Matching</h2>
    <ul>
	<li class="fragment">Especially useful for accessing tagged unions <b>safely</b></li>
	<li class="fragment">Tagged unions == variant types == sum types</li>
    </ul>
</section>
<section>
    <h3>C: Tagged union definition</h3>
    <pre><code class="hljs c" data-trim contenteditable>
enum code {
    CODE__OK,
    CODE__ERR_WITH_VAL,
    CODE__ERR_WITH_STR,
};

struct code_struct {
    enum code tag;
    union {
	int val;
	const char *str;
    } u;
};
    </code></pre>
</section>
<section>
    <h3>C: Tagged union access</h3>
    <pre><code class="hljs c" data-trim contenteditable>
void example(struct code_struct cs) {
    switch (cs.tag) {
	case CODE__OK:
	    printf("OK\n");
	    break;
	case CODE__ERR_WITH_VAL:
	    printf("%d\n", cs.u.val);
	    break;
	case CODE__ERR_WITH_STR:
	    printf("%s\n", cs.u.str);
	    break;
	}
    }
}
    </code></pre>
</section>
<section>
    <h3>C++: Variant type (C++17)</h3>
    <pre><code class="hljs c++" data-trim contenteditable>
struct empty {};
struct err_with_val {
    int errno;
};
struct err_with_str {
    std::string errstr;
};

using code = std::variant&lt;empty, err_with_val, err_with_str&gt;;
    </code></pre>
</section>
<section>
    <h3>Rust: Same tagged union access</h3>
    <pre><code class="hljs rust" data-trim contenteditable>
enum Code {
    Ok,
    ErrVal(u32),
    ErrStr(String),
}

fn example(Code cs) {
    match cs {
	Code::Ok => println!("OK"),
	Code::ErrVal(val) => println!("errno: {}", val),
	Code::ErrStr(val) => println!("msg: {}", val),
    }
}
    </code></pre>
    <ul>
	<li class="fragment">
    If 'match' not exhausive we get a compilation error.
	</li>
    </ul>
</section>
<section>
    <h3>Rust: Enum value construction</h3>
    <pre><code class="hljs rust" data-trim contenteditable>
		    Code::Ok
    </code></pre>

    <pre><code class="hljs rust" data-trim contenteditable>
		    Code::ErrVal(3)
    </code></pre>

    <pre><code class="hljs rust" data-trim contenteditable>
		    Code::ErrString(String::new("A"))
    </code></pre>

    <ul>
	<li class="fragment">
	NOTE: The content of this `String` type is heap-allocated
	for simplicity of the example, but we could have used a reference string
	type with usage-dependent memory location.
	</li>
    </ul>
</section>
<section>
    <h3>Elaborate Matching in Deconstruction</h3>
    <pre><code style="font-size:70%; line-height: 100%" class="hljs rust" data-trim contenteditable>
enum Shape {
    Rect(u32, u32),
    Cube(u32, u32, u32),
}

fn example(Shape cs) {
    match cs {
	Shape::Rect(1, _) =>
	   println!("Rect with 1 as first dimension"),
	Shape::Rect(_, 1) =>
	   println!("Rect with 1 as second dimension"),
	Shape::Rect(_, _) =>
	   println!("All other boxes"),
	Shape::Cube(width, _, 10) =>
	   println!("Only certain Cube's width {}", width),
	_ => println!("all other possibilities"),
    }
}
    </code></pre>
</section>
<section>
    <h3>Option type</h3>
    <pre><code style="font-height:50%" class="hljs rust" data-trim contenteditable>
enum Option&lt;T&gt; {
    None,
    Some(T),
}
    </code></pre>
</section>
